#include "RooTFnBinding.h"

using namespace RooFit;


void compareResults()
{

  // R e a d   w o r k s p a c e   f r o m   f i l e
  // -----------------------------------------------
 
  // Open input file with workspace (generated by rf14_wspacewrite)
  TFile *f_gaus = new TFile("gaus_workspace.root");
  TFile *f_bukin = new TFile("bukin_workspace.root");
  TFile *f_voigt = new TFile("voigt_workspace.root");
 
  // Retrieve workspace from file
  RooWorkspace *w_gaus = (RooWorkspace *)f_gaus->Get("w");
  RooWorkspace *w_bukin = (RooWorkspace *)f_bukin->Get("w");
  RooWorkspace *w_voigt = (RooWorkspace *)f_voigt->Get("w");

  RooRealVar *mass = w_gaus->var("mass");
  RooAbsData *signal = w_gaus->data("signal");

  RooAbsPdf *gauss = w_gaus->pdf("gauss");
  RooAbsPdf *voigt = w_voigt->pdf("voigt");
  RooAbsPdf *bukin = w_bukin->pdf("bukin");


  TCanvas *c  = new TCanvas("c","c",1200,1200);
 
  c->SetLogy();
  RooPlot *xframe = mass->frame(Title("Signal fit"));
  signal->plotOn(xframe);
  gauss->plotOn(xframe, LineColor(kRed));
  voigt->plotOn(xframe, LineColor(kBlue));
  bukin->plotOn(xframe, LineColor(kGreen)); 
  xframe->Draw();
  auto leg = c->BuildLegend();
  leg->SetFillColor(0);
  leg->SetLineColor(0);
  leg->Draw();
  c->Print("SignalCompariso.pdf");

}


void RF_Fit_Tutorial(TString signal_function = "gaus", Bool_t fixSig = false, Bool_t fixBkg = false)
{


  //INSTRUCTIONS
  //you can set signal function when running the job (default is gaussian)
  //root -l 'RootFit_Fit_Tutorial("voigt")'

  ///////////////////////////////////
  //Global config
  ///////////////////////////////////

  gSystem->Load("libRooFit");
  gStyle->SetOptStat(0);
  gStyle->SetEndErrorSize(0.);
  gStyle->SetErrorX(0.0);

  //////////////////////////////////////////

  ///////////////////////////////////
  //Macro option
  bool createWspace=false; //crea il workspace
  bool scanLL = false; //likelihood scan
  bool doContour = false; //contour plot
  bool doPlots = true; //extra plot
  bool useExp  = true; //fondo esponenziale
  ///////////////////////////////////

  //Retrieve histos
  TString nomeHisto = "h_m";
  TFile *file_data = new TFile("data_out.root");
  TFile *file_higgs = new TFile("Higgs_out.root");
  TH1F *h_higgs = (TH1F*)file_higgs->Get(nomeHisto);
  TH1F *h_data = (TH1F*)file_data->Get(nomeHisto);
  
  //Add event weights
  h_data->Sumw2();
  h_higgs->Sumw2();
  

  //Make Up ---------------------
  for(int i = 1; i<= h_data->GetNbinsX();i++) h_data->SetBinError(i, TMath::Sqrt(h_data->GetBinContent(i)));
  h_data->SetMarkerStyle(20);
  h_data->SetLineColor(1);
  h_data->SetTitle("");

  h_higgs->SetLineColor(2);
  h_higgs->SetFillColor(2);

  //-----------------------
  
  //----- lumi rescale------------------

  Double_t lumi = 10060;
  h_higgs->Scale(lumi);

  //-----------------------
     
  cout <<"******************************************"<<endl;
  cout <<"Lumi: "<<lumi<<endl;
  cout <<"MC Higgs events: "<<h_higgs->Integral()<<endl;
  cout <<"Data events: "<<h_data->Integral()<<endl;
  cout <<"******************************************\n"<<endl;
  
  ///////////////////////////////////
  //Start of RooFit tutorial  
  ///////////////////////////////////

  //First, define the observable for the analysis: the particle's reconstructed mass
  Double_t range_min = 106, range_max = 160;
  RooRealVar mass("mass", "mass", range_min, range_max);


  //-----SIGNAL----------
  //Define mean and sigma for signal PDF
  Double_t initial_mass = 125., min_mass=115., max_mass = 135.;

  /*
  Exercise 1.1: Implementa un fit, definendo le variabili di interesse, le funzioni del segnale, del fondo e la totale
    - Ex 1.1a: definisci le variabili e le funzioni di segnale e fondo
    - Ex 1.1b: definisci il numero di eventi di segnale e fondo nel modello
    - Ex 1.1c: costruisci la pdf totale

  Exercise 1.2: Cambia la pdf del fondo con un polinomio di Chebychev (ricordati che useExp deve stare a false)
  Exercise 1.3: Proviamo a fittare altre funzioni per il segnale

  Exercise 2.1: proviamo a "giocare" con i parametri, fissandone qualcuno tra segnale e fondo

  Exercise 3.1: fit di likelihood e contour plot. Setta a true le flag scanLL e doContour

  Exercise 4.1: Salviamo in un workspace (createWspace deve essere true), e giriamo la funzione compareResults per confrontare i fit dei segnali 
  
  */  
  //RooRealVar mean("mean", "mean of gaussian", ??, ??, ??); //Ex 1.1a
  //RooRealVar sigma("sigma", "sigma of gaussian", ??,??,??); //Ex 1.1a

  //Crystal Ball convoluzione tra una gaussiana (corpo centrale) e una legge di potenza nelle code
  //Ex 1.3a
  //Voigtian: breit-Wigner convoluta con Gaussiana
  //Ex 1.3b
  //Bukin: convoluzione tra una gaussiana e un’esponenziale con l’aggiunta di funzioni polinomiali nelle code, modella picchi asimmetrici
  //Ex 1.3c

  //Construct the signal P.D.F.
  RooGaussian gauss("gauss", "Signal PDF", mass, mean, sigma); //Ex 1.1a
  
  
  //-----BKG----------
  //Now define the background P.D.F, a simple exponential
  //RooRealVar tau("tau", "exponential function parameter",??,??,??); //Ex 1.1a
  //RooExponential expo("expo","Background PDF", ??,??); //Ex 1.1a

  //Exercise 1.2 continua tu
  //RooRealVar a0("a0","a0",0.7,-1000,1000); Ex 1.2
  
  // RooChebychev cpol("cpol","cpol",mass,RooArgList(a0, .....)); //Ex 1.2  

  //Ex 1.1b
  //Define the number of signal and background events in the model
  //Double_t nsig_exp = ??; //Ex 1.1b (usa la funzione Integral() di ROOT sugli istogrammi)
  //Double_t mu_max = ??; //Ex 1.1b

  //RooRealVar Nsig_exp("Nsig_exp", "Number of signal events",??);//Ex 1.1b
  //RooRealVar Nbkg("Nbkg", "Number of background events", h_data->Integral(), h_data->Integral() - nsig_exp*mu_max, h_data->Integral());//Ex 1.1b
  //RooRealVar mu("mu", "signal strength in units of SM expectation", ??,??,??);  
  //RooProduct Nsig("Nsig", "Number of signal events", RooArgSet(mu, Nsig_exp));//Ex 1.1b
  ///////////////////////////////////////////////////////////////////////////////////////

  //Building datasets from histograms
  //Passiamo dagli histo di root a quelli di RooFit
  RooDataHist *data = new RooDataHist("data", "data", mass, Import(*h_data));
  RooDataHist *signal = new RooDataHist("signal", "signal", mass, Import(*h_higgs));
  
  
  RooAddPdf *PDFtot;

  cout <<"\033[31m--------------------------------------------"<<endl;
  cout <<"\033[31m--------------FIT TO SIGNAL-------------------"<<endl;
  cout <<"\033[31m--------------------------------------------\033[0m"<<endl;


  //Now construct the total PDF
  //La PDF totale sarà Nsig*f_sig + Nbkg*f_bkg
  if (signal_function.Contains("gaus")){
    if (useExp) PDFtot = new RooAddPdf("PDFtot", "PDFtot", RooArgList(gauss, expo), RooArgList(Nsig, Nbkg)); //Ex 1.1c
    else  PDFtot = new RooAddPdf("PDFtot", "PDFtot", RooArgList(gauss, expo), RooArgList(Nsig, Nbkg)); //Ex 1.2 Attenzione che dovete poi scrivere la funzione corretta cpol
    gauss.fitTo(*signal,SumW2Error(kFALSE));  //fit all'istogramma di segnale
  }
  else if (signal_function.Contains("voigt")){
    //dummy: correggi con la funzione giusta quando arrivi a Ex 1.3
    
    1==1;

  }
  else if (signal_function.Contains("CB")){
    //dummy: correggi con la funzione giusta quando arrivi a Ex 1.3
    1==1;
  }
  else if (signal_function.Contains("bukin")){ 
    //dummy: correggi con la funzione giusta quando arrivi a Ex 1.3
    1==1;
  }
  else {
    cout <<"UNKNOWN FUNCTION!!!! EXIT"<<endl;
    exit(EXIT_FAILURE);
   }

  //Stampa i valori del fit(questi sono comuni a tutte le funzioni, gli altri vanno stampati negli if sopra)
  mean.Print();
  sigma.Print();

  
  //Now plot hists  and the fitted PDF
  RooPlot *sig_massframe = mass.frame();
  signal->plotOn(sig_massframe);
  if (signal_function.Contains("gaus")) gauss.plotOn(sig_massframe);
  else if (signal_function.Contains("voigt"))gauss.plotOn(sig_massframe); //dummy: correggi con la funzione giusta quando arrivi a Ex 1.3
  else if (signal_function.Contains("CB"))gauss.plotOn(sig_massframe); //dummy: correggi con la funzione giusta quando arrivi a Ex 1.3
  else if (signal_function.Contains("bukin")) gauss.plotOn(sig_massframe); //dummy: correggi con la funzione giusta quando arrivi a Ex 1.3

  cout <<"\033[31m--------------------------------------------"<<endl;
  cout <<"\033[31m--------------FIT TO DATA-------------------"<<endl;
  cout <<"\033[31m--------------------------------------------\033[0m"<<endl;


  if(fixSig){
    cout <<"\n\n\033[31m--------------Fixing signal parameters-------------------\033[0m"<<endl;

    sigma.setConstant(kTRUE);
    sigma.Print();
    if (signal_function.Contains("voigt")){
      //dummy: correggi con la funzione giusta quando arrivi a Ex 2.1
      1==1;
    }
    if (signal_function.Contains("CB")) {
      //dummy: correggi con la funzione giusta quando arrivi a Ex 2.1
      1==1;
    }

    if (signal_function.Contains("bukin")) {
      //dummy: correggi con la funzione giusta quando arrivi a Ex 2.1
      1==1;

    }

    
  }

  else{
    cout <<"\n\n\033[31m--------------Free signal parameters-------------------\033[0m"<<endl;
  }
  if(fixBkg){

    cout <<"\n\n\033[31m--------------Fixing bkg parameters-------------------\033[0m"<<endl;
    if(!useExp){
    a0.setConstant(kTRUE);
    a0.Print();
    //Ex 2.1: aggiungi i parametri rimanenti
    }   cout <<"\033[0m"<<endl;
  }

  // Get list of parameters of a p.d.f given set of observables
  RooArgSet* params = PDFtot->getParameters(mass) ;

  // Make a snapshot of the parameterlist
  RooArgSet* savedParams = (RooArgSet*)params->snapshot() ;
  
  //fit ai dati
  RooFitResult *r = PDFtot->fitTo(*data,Save()); //Salviamo i risultati in un puntatore
  cout <<"\n\n\033[31m---------------------------------"<<endl;
  mean.Print();
  Nbkg.Print();
  Nsig.Print();
  mu.Print();
  r->Print("v"); //Stampa tutte le info del fit

  cout <<"Total events: "<<Nsig.getVal()+Nbkg.getVal()<<endl;
  cout <<"\n\n\033[31m--------------------------------\033[0m"<<endl;
  
  
  //Now plot the data and the fitted PDF
  RooPlot *data_massframe = mass.frame();
  data->plotOn(data_massframe);

  
  //One can also plot the single components of the total PDF, like the background component
  if (useExp) PDFtot->plotOn(data_massframe, Components(expo), LineStyle(kDashed), LineColor(kRed));
  else PDFtot->plotOn(data_massframe, Components(cpol), LineStyle(kDashed), LineColor(kRed));
  PDFtot->plotOn(data_massframe);
  
  //Actually plot the result
  TString bkg_function = "_Chebpol";
  if (useExp) bkg_function = "_Expo";
  TCanvas *c1 = new TCanvas("c1","c1",1200,600);
  c1->Divide(2);
  c1->cd(1);
  sig_massframe->Draw();
  c1->cd(2);
  data_massframe->Draw();
  c1->SaveAs("RooFit_"+signal_function+bkg_function+".pdf");
  c1->Update();

  if(doPlots){
    //Ratio plots
    //Simplest case: switch to root
    TCanvas *c2 = new TCanvas ("c2","c2",1200,600);
    c2->Divide(2);
  
    //Create after fit functions
    //First create RooChebychev and then pass to TF1
    Double_t fittedBkg = Nbkg.getVal();

    TF1 *bkgAfterFit;
    if(useExp) {
      RooExponential *BkgFitted = new RooExponential("BkgFitted","BkgFitted",mass,tau);
      bkgAfterFit = (TF1*)BkgFitted->asTF(mass,RooArgList(tau),mass);
    }
    else {
      RooChebychev *BkgFitted = new RooChebychev("BkgFitted","BkgFitted",mass,RooArgList(a0,a1,a2));
      bkgAfterFit = (TF1*)BkgFitted->asTF(mass,RooArgList(a0,a1,a2),mass);
    }
   
    bkgAfterFit->SetRange(range_min, range_max);
    bkgAfterFit->SetNpx(1000);
    TH1 *h_bkgAfterFit = (TH1F*)bkgAfterFit->CreateHistogram();
    cout <<"----bkg function ---"<<endl;
    cout <<"BKG After fit: "<<bkgAfterFit->Integral(range_min, range_max) <<endl;
    for (uint i =0; i<bkgAfterFit->GetNpar();i++) cout <<bkgAfterFit->GetParName(i)<<"  "<<bkgAfterFit->GetParameter(i)<<endl;
    h_bkgAfterFit->Scale(Nbkg.getVal()*h_data->GetBinWidth(1));
    cout <<"Histo BKG After fit: "<<h_bkgAfterFit->Integral() <<endl;
    cout <<"-------"<<endl;

    //fit
    TF1 *AfterFit = (TF1*)PDFtot->asTF(mass, *PDFtot->getParameters(mass),mass);
    AfterFit->SetRange(range_min, range_max);
    AfterFit->SetNpx(1000);
    TH1 *h_AfterFit = (TH1F*)AfterFit->CreateHistogram();
    cout <<"---- function ---"<<endl;
    cout <<" After fit: "<<AfterFit->Integral(range_min, range_max) <<endl;
    for (uint i =0; i<AfterFit->GetNpar();i++) cout <<AfterFit->GetParName(i)<<"  "<<AfterFit->GetParameter(i)<<endl;
    h_AfterFit->Scale((Nbkg.getVal()+ Nsig.getVal())*h_data->GetBinWidth(1));
    cout <<"Histo  After fit: "<<h_AfterFit->Integral() <<endl;
    cout <<"-------"<<endl;
  
    
    //clone data and subtract  
    //to get the points
    TH1F *h_data_clone = (TH1F*)h_data->Clone("dataClone");
    cout <<"BEFORE SUBTRACTION: "<<h_data_clone->Integral()<<endl;
    h_data_clone->Add(bkgAfterFit, -1*fittedBkg*h_data->GetBinWidth(1));
    cout <<"AFTER "<<h_data_clone->Integral()<<endl;

    //signal after bkg subtraction
    TH1F *h_sig_clone = (TH1F*) h_AfterFit->Clone("sigClone");
    h_sig_clone->Add(bkgAfterFit, -1*fittedBkg*h_data->GetBinWidth(1));


  
    TLine *hline = new TLine(h_data_clone->GetXaxis()->GetXmin(),0,h_data_clone->GetXaxis()->GetXmax(),0);
    hline->SetLineColor(4);
    hline->SetLineWidth(2);
    hline->SetLineStyle(2);

  
    c2->cd(1);  
    h_data_clone->Draw();
    hline->Draw("same");
    h_sig_clone->Draw("HIST same");
  
    c2->cd(2);
    h_data->Draw();
    h_AfterFit->Draw("HIST same");
    c2->Print("Final_"+signal_function + bkg_function+".pdf");
  }
    
  
  if (scanLL){
    cout <<"\033[32m--------------------------------------------"<<endl;
    cout <<"\033[32m--------------LL PLOTS-------------------"<<endl;
    cout <<"\033[32m--------------------------------------------\033[0m"<<endl;

    //*params = *savedParams; 

    // Construct unbinned likelihood
    RooAbsReal* nll = PDFtot->createNLL(*data,RooFit::Extended(kTRUE)) ;

    // Minimize likelihood w.r.t all parameters before making plots
    RooMinimizer m(*nll);
    m.improve();
    m.migrad() ;
    m.hesse() ;
    
    // Plot likelihood scan in mass 
    RooPlot* frame1 = mean.frame(Bins(20),Range(120,130),Title("LL in mass")) ;
    nll->plotOn(frame1,ShiftToZero()) ;
    frame1->SetMinimum(-0.5);
    frame1->SetMaximum(10);
  
    // Plot likelihood scan in Nsig 
    RooPlot* frame2 = mu.frame(Bins(20), Range(0, mu_max),Title("LL in Nsig")) ;
    nll->plotOn(frame2,ShiftToZero()) ;
    frame2->SetMinimum(-0.5);
    frame2->SetMaximum(10);


    cout <<"\n\n\033[32m---------------------------------"<<endl;
    cout <<"FIT AFTER LIKELIHOOD PLOT"<<endl;

    mean.Print();
    Nbkg.Print();
    Nsig.Print();
    mu.Print();
    r->Print("v");
    cout <<"\n\n\033[32m--------------------------------\033[0m"<<endl;


    RooPlot *frame3;
    if(doContour){
      frame3 = m.contour(mean,mu,1,2) ;
      frame3->SetTitle("Minuit contour plot") ;
      frame3->GetXaxis()->SetLimits(120,135);
      frame3->GetYaxis()->SetLimits(0,2);
    }

    //    RooAbsReal* pll_mu = nll->createProfile(mu) ;
    // Plot the profile likelihood in frac
    //pll_mu->plotOn(frame2,LineColor(kRed)) ;


    // Make canvas and draw RooPlots
    TCanvas *c2 = new TCanvas("rf605_profilell","rf605_profilell",800, 400);
    c2->Divide(3);
    c2->cd(1) ; gPad->SetLeftMargin(0.15) ; frame1->GetYaxis()->SetTitleOffset(1.4) ; frame1->Draw() ;
    c2->cd(2) ; gPad->SetLeftMargin(0.15) ; frame2->GetYaxis()->SetTitleOffset(1.4) ; frame2->Draw() ;
    if(doContour)c2->cd(3) ; gPad->SetLeftMargin(0.15) ; frame3->GetYaxis()->SetTitleOffset(1.4) ; frame3->Draw() ;
    c2->SaveAs("LLScan_" + signal_function + bkg_function + ".pdf");
  

    //PDFtot.fitTo(*data,RooFit::Extended());
    
    cout <<"\n\n\033[32m---------------------------------"<<endl;
    cout <<"FIT AFTER CONTOUR PLOT"<<endl;

    mean.Print();
    Nbkg.Print();
    Nsig.Print();
    mu.Print();
    r->Print("v");
    cout <<"\n\n\033[32m--------------------------------\033[0m"<<endl;
    delete nll ;
    
  }

  //r->Print("V");

  if(createWspace){
    // C r e a t e   w o r k s p a c e ,   i m p o r t   d a t a   a n d   m o d e l
    // -----------------------------------------------------------------------------
 
    // Create a new empty workspace
    RooWorkspace *w = new RooWorkspace("w", "workspace");
 
    // Import model and all its components into the workspace
    w->import(*PDFtot);
    if (signal_function.Contains("gaus")) w->import(gauss);
    else if (signal_function.Contains("voigt")) w->import(voigt);
    else if (signal_function.Contains("bukin")) w->import(bukin);



   
    // Import data into the workspace
    w->import(*data);
    w->import(*signal);

   
    // Print workspace contents
    w->Print();
 
    // S a v e   w o r k s p a c e   i n   f i l e
    // -------------------------------------------
 
    // Save the workspace into a ROOT file
    w->writeToFile(signal_function + "_workspace.root");
  }
}
